# CTF Level 2
The hint for this level is "combine the parts".

The command unlocks 1 new file.
By using the _file_ utility we can see that the new file is an ELF executable.

If we try running the ELF, a hexadecimal number is printed to the standard output. When using the command _echo $?_ a 0 is printed, meaning the file is exiting with no errors.

Additionally, adding a command-line parameter does not change the functionality, and different numbers are printed, suggesting a use of the libc function _rand_:
```
$ ./lvl2
88
$ ./lvl2 foobar
d6
$ ./lvl2 foobar
6c
```

And as expected, the output of the _ltrace_ utility shows that the libc functions: _time_, _srand_, _rand_ & _puts_ are all used:
```
$ ltrace -i -C ./lvl2
[0x40050b] time(0) = 1643579146
[0x400512] srand(0x61f7070a, 0x7ffce55dad88, 0x7ffce55dad98, 0) = 0
[0x400517] rand(0x7f9b06041620, 0x7ffce55dac6c, 0x7f9b060410a4, 0x7f9b0604111c) = 0x60d39528
[0x400531] puts("74"74) = 3
```

The _strings_ & _strace_ utilities offer no new useful information.

The disassembly of the executable shows that the random number generated by _rand_ is manipulated and then used as an offset to an address whose content will be passed on to _puts_:
```
  400506:	e8 c5 ff ff ff       	call   4004d0 <time@plt>
  40050b:	89 c7                	mov    edi,eax
  40050d:	e8 ae ff ff ff       	call   4004c0 <srand@plt>
  400512:	e8 c9 ff ff ff       	call   4004e0 <rand@plt>
  400517:	99                   	cdq    
  400518:	c1 ea 1c             	shr    edx,0x1c
  40051b:	01 d0                	add    eax,edx
  40051d:	83 e0 0f             	and    eax,0xf
  400520:	29 d0                	sub    eax,edx
  400522:	48 98                	cdqe   
  400524:	48 8b 3c c5 60 10 60 	mov    rdi,QWORD PTR [rax*8+0x601060]
  40052b:	00 
  40052c:	e8 6f ff ff ff       	call   4004a0 <puts@plt>
```

Since rand creates a random number we'll have to analyse the executable dynamically.

We'll set a breakpoint at the call to _puts_.
In the current run, the value of rdi is 0x4006d9.

_readelf --sections --wide_ shows us that the .rodata section starts at address 0x4006c0 and the next section starts at 0x4006f4, meaning that the value that rdi points to is in the .rodata section:
```
$ readelf --sections --wide lvl2
Section Headers:
[Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
...
[16] .rodata           PROGBITS        00000000004006c0 0006c0 000034 00   A  0   0  4
[17] .eh_frame_hdr     PROGBITS        00000000004006f4 0006f4 000034 00   A  0   0  4
...
```
The contents of the section can be dumpped with objdump:
```
$ objdump -s -j lvl2
Contents of section .rodata:
4006c0 01000200 30330034 66006334 00663600  ....03.4f.c4.f6.
4006d0 61350033 36006632 00626600 37340066  a5.36.f2.bf.74.f
4006e0 38006436 00643300 38310036 63006466  8.d6.d3.81.6c.df
4006f0 00383800                             .88.
```
Some of the values that we saw when we ran _lvl2_ can be seen in the section.

With the hint we received at the start, we can infer that the values in the .rodat sections can be combined into a flag: 034fc4f6a536f2bf74f8d6d3816cdf88 which the oracle accepts!
